/**
 * Richu Jacob
 * ID:110257792
 * Homework #5
 * Recitation 01
 * TA: Charles Chen
 * Grading TA: Shilpi Bhattacharyya
 */

import java.io.BufferedReader;
import java.io.*;

public class TreeNavigator {
    /**
     * A reference to the root TreeNode of this tree.
     * A reference to the currently selected TreeNode in the tree.
     */
    private TreeNode root;
    private TreeNode cursor;

    /**
     * a constructor that sets root and cursor to properly
     */
    public TreeNavigator (){
        this.root = root;
        this.cursor = root;
    }

    /**
     * Reads in a text file describing a TreeNavigator. See sample input for an example.
     * Preconditions: treeFile is a non-null, non-empty String that points to a file that
     * exists that is readable and valid.
     * Returns a new TreeNavigator generated by the passed in text file.
     * the strings in the file are split using split method
     * if its a 0, go left
     * if its a 1, go right
     * and store the keywords
     * @param treeFile is the param used to read and build the file
     * @return a tree that has been built using paramter
     * File not exception and IOException are handled if the file is not read in properly
     */
    public static TreeNavigator buildTree(String treeFile){
        try {
            File tree = new File(treeFile);
            BufferedReader readTree = new BufferedReader(new FileReader(tree));
            String text=readTree.readLine();
            TreeNavigator newTree = new TreeNavigator();
            //check that text is not null and then check text is not empty
            if(text.isEmpty()){
                return null;
            }else {
                //cursor = null;
                //root = null;
                while (text != null) {
                    //cursor = root;
                    String directions = text.split(";")[0];
                    if(directions.length()==1){
                        String raw = text.split(";")[1];
                        String [] keywords = raw.split(",");
                        newTree.setRoot(new TreeNode(keywords));
                        newTree.cursor=newTree.root;
                        text=readTree.readLine();

                    }
                    String rawWords = text.split(";")[1];
                    String [] keywords = rawWords.split(",");
                    TreeNode node = new TreeNode(keywords);
                    String ref = text.split(";")[0];
                    String [] reference = ref.split("-");
                    newTree.cursor=newTree.root;
                    for (int i = 1; i < reference.length; i++) {
                        //char check = text.charAt(i);
                        if(reference[i].equals("0")) {

                            if(newTree.cursor.getLeft()==null){
                                newTree.cursor.setLeft(node);
                            }else{
                                newTree.cursor=newTree.cursor.getLeft();
                            }


                        }else{
                            if(newTree.cursor.getRight()==null){
                                newTree.cursor.setRight(node);
                            }else{
                                newTree.cursor = newTree.cursor.getRight();
                            }

                        }
                    }text = readTree.readLine();

                }
                return newTree;

            }

        }catch(FileNotFoundException e) {
           System.out.println("The file is not found");
        }
        catch(IOException e){
                System.out.println("There is an Input/Ouput error");
        }

        return null;
    }

    /**
     * Classifies the text with the given tree and returns the classification as a String.
     * use split method and check keywords are equal to splited array
     * @param text that is split and then return the request
     * @return the request of the user based on param
     */
    public String classify(String text){
        String [] classify = text.split(" ");
        //TreeNode key = new TreeNode(classify);
        cursor=root;
        //String path="";
        for(int i=0; i<cursor.getKeywords().length; i++){

            for(int j=0; j<classify.length; j++){
                if(cursor.getKeywords()[i].equalsIgnoreCase(classify[j])){
                    cursor=cursor.getRight();
                    i=0;
                    if(cursor.isLeaf()){
                        return cursor.getKeywords()[0];

                    }
                }else if(i==cursor.getKeywords().length-1&&j==classify.length-1){
                    cursor=cursor.getLeft();
                    i=-1;
                    if(cursor.isLeaf()){
                        return cursor.getKeywords()[0];

                    }
                }
            }
        }return null;
    }

    /**
     * Gets the current path of the cursor.
     * use the same thing as classify except adds to global string
     * whenever there is 0, 1 or adds to string using not and is respectively
     * also gives the final destination once it reaches the end
     * @param text
     * @return
     */
    public String getPath(String text){

        String [] path = text.split(" ");
        cursor=root;
        String global="";
        for(int i=0; i<cursor.getKeywords().length; i++){

            for(int j=0; j<path.length; j++){
                if(cursor.getKeywords()[i].equalsIgnoreCase(path[j])){
                    global += "IS " + cursor.getKeywords()[i] + ", ";
                    cursor=cursor.getRight();
                    i=0;
                    if(cursor.isLeaf()){
                        global+= " DECISION: " + cursor.getKeywords()[0];

                    }//j=0;
                }else if(i==cursor.getKeywords().length-1&&j==path.length-1){
                    global += "NOT " + cursor.getKeywords()[i] + ", ";
                    cursor=cursor.getLeft();
                    i=0;
                    if(cursor.isLeaf()){
                        global+= " DECISION: " + cursor.getKeywords()[0];

                    }//j=0;
                }
            }
        }return global;

    }

    /**
     * resets the cursor
     */
    public void resetCursor(){
        cursor=root;
    }

    /**
     * moves the cursor to the left
     */
    public void cursorLeft(){
        cursor=cursor.getLeft();
    }

    /**
     * moves the cursor to the right
     */
    public void cursorRight(){
        cursor=cursor.getRight();
    }

    /**
     * checks if cursor is null if not returns cursor
     * @return the cursor
     */
    public TreeNode getCursor(){
        if(cursor==null){
            return null;
        }else{
            return cursor;
        }

    }

    /**
     * sets the root based on the parameter
     * @param root that is used to set the root
     */
    public void setRoot(TreeNode root){
        this.root = root;
    }

    /**
     * gets the root and returns the root
     * @return the root
     */
    public TreeNode getRoot(){
        return root;
    }

    /**
     * sets the cursor based on the parameter
     * @param cursor that is set as the cursor
     */
    public void setCursor(TreeNode cursor) {
        this.cursor = cursor;
    }

    /**
     * edits the keywords at the current cursor and splits based on commas
     * @param text is used to edit
     */
    public void editCursor(String text){
        cursor.setKeywords(text.split(","));
    }
}
